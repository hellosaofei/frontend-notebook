# js 模块化简介

早期的 js 代码量不是很大，大都放在一个 js 文件中，醉随着网站越来越庞大，需求越来越复杂，一个 js 文件显然是不行的。

- 代码耦合度高
- 容易全局污染
  因此，需要将一个复杂的程序按照一定规则进行拆分组合

**模块化进化**

- 直接定义为全局变量：全局污染

```js
function test() {
  //...
}
```

- 转移到一个对象中:不安全

```js
var obj = {
  test: function () {
    //...
  },
};
```

- 立即执行函数:不利于修改

```js
var test = (function () {
  //...
})();
```

- 立即执行函数+引入依赖

```js
var test = (function () {
  //...
})(window);
```

**模块化存在问题**

- 请求过多:拆分为多个文件后，html 文件需要使用多个`script`标签进行依赖导入

```html
<script src="test1.js"></script>
<script src="test2.js"></script>
<script src="test3.js"></script>
<script src="test4.js"></script>
```

- 依赖模糊：各个模块之间的引用关系不清晰
- 难以维护

# js 模块化规范

## CommonJS

**特点**

1. 每个文件都可当做一个独立的模块
2. 主要应用于服务端（nodeJS）：模块在运行时同步加载
3. 浏览器端使用`CommonJS`规范时：需要提前打包处理
   > - 浏览器不认识`require`语法
   > - 浏览器请求资源时间过长

**基本语法**

- 暴露模块
  > - 默认暴露：module.exports=value
  > - 分别暴露：exports.xxx=value

> 模块向外暴露的对象都是`exports`对象，只不过对其进行了赋值

- 导入模块

> - `var 变量名=require('模块名')`

### 使用\*\*

**node 端：直接使用**

- 项目目录

```
|- module1.js
|- module2.js
|- main.js
```

- module1.js

```js
// 向外暴露一个对象
module.exports = {
  name: "张三",
};
```

- module2.js

```js
exports.foo = function () {
  console.log("李四");
};
exports.name = "李四";
```

- main.js

```js
var module1 = require("./module1.js");
var module2 = require("./module2.js");

console.log(module1.name);
module2.foo();
console.log(module2.name);
```

- 浏览器端：使用`browerify`工具进行打包

## AMD

## ESM
