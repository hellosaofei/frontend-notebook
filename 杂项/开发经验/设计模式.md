# 工厂模式

# 装饰器模式

特征：在不改变原始类的情况下扩展其功能

# 策略模式

## 适用场景

- 场景一：
  > 场景：在一个物流管理系统中，需要一个功能来处理不同类型的货物运输请求，如陆运、空运或海运。该系统应能够根据运输类型的不同选择不同的处理策略。
  > 解释：策略模式通过定义一系列算法（在这里是运输方式），封装每一个算法，并使它们可以相互替换，特别适合于有多种类似行为或策略的系统。

# 模板方法模式

- 核心逻辑：将**部分逻辑**以具体方法以及**具体构造子**的形式实现，然后声明一些**抽象方法**来**迫使子类实现剩余的逻辑**。

不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。先制定一个顶级逻辑框架，而将逻辑的细节留给具体的子类去实现

<img src="../pic/设计模式-模板方法模式.png">

# 观察者模式

# 发布订阅模式

规定了一个系统之间的不同部分该如何进行消息传递，

- 发布者和订阅者之间通过消息代理 （Pub/Sub Message Broker）进行通信
- 发布订阅通常是一种 一对多 的依赖关系
- 订阅者通常有多个，其内部状态依赖于发布者的状态改变

## 一个简单的实例

- 下面代码中，不使用面向对象的编程方式。仅仅实现一个发布订阅模式的效果
- 由于未指定订阅事件的类型，每次`emit`函数触发后，都会调用 list 中存储的订阅函数 一次

```js
var myMitt = {};

// 一个列表，用于存储
myMitt.list = [];

// 订阅
myMitt.on = function (fn) {
  this.list.push(fn);
};

// 发布
myMitt.emit = function (...args) {
  this.list.forEach((fn) => {
    fn.apply(this, args);
  });
};

// 订阅两个函数
myMitt.on(function (...args) {
  // 订阅函数的功能
  console.log("这是第一个订阅函数,接收到的参数为：", args);
});
myMitt.on(function (...args) {
  // 订阅函数的功能
  console.log("这是第二个订阅函数,接收到的参数为：", args);
});

myMitt.emit("触发器一！！！", "张三！！");
```
